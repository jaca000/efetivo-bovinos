<!doctype html>
<html lang="pt-PT">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Monte do Pasto ‚Äî Efetivo Bovinos</title>
<style>
  :root{--bg:#f4f5f2;--card:#fff;--line:#ddd;--muted:#666}
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;background:var(--bg);margin:0;padding:18px;color:#222}
  h1{margin:0 0 10px;font-size:18px}
  .bar{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-bottom:12px}
  input[type="file"]{padding:8px;background:#fff;border:1px solid #ccc;border-radius:10px}
  .status{font-size:13px;color:var(--muted)}
  .card{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:12px}
  table{border-collapse:collapse;width:100%;background:#fff}
  th,td{border:1px solid #ccc;padding:8px;text-align:center;font-size:13px}
  th{background:#eee;position:sticky;top:0}
  .ok{color:green;font-weight:700}
  .warn{color:orange;font-weight:800}
  .bad{color:#b00020;font-weight:900}
  .muted{color:var(--muted)}
  .small{font-size:12px;color:var(--muted);margin-top:8px;line-height:1.35}
  .pill{display:inline-block;padding:2px 10px;border:1px solid #bbb;border-radius:999px;background:#fafafa}
</style>
</head>
<body>

<h1>Efetivo Bovinos ‚Äî Estimativa Atual (Meteorologia autom√°tica + Alertas)</h1>

<div class="bar">
  <input type="file" id="fileInput" accept=".csv,text/csv">
  <div class="status" id="status">Carrega o teu <b>efetivo_bovinos.csv</b></div>
</div>

<div class="card">
  <table>
    <thead>
      <tr>
        <th>Animal</th>
        <th>Grupo</th>
        <th>Sexo</th>
        <th>Peso Atual</th>
        <th>Data Peso Atual</th>
        <th>Temp. m√©dia per√≠odo</th>
        <th>Fator clima</th>
        <th>Peso Estimado Hoje</th>
        <th>Confian√ßa</th>
        <th>Estado</th>
      </tr>
    </thead>
    <tbody id="tbody"></tbody>
  </table>

  <div class="small">
    <b>Estado üü¢üü°üî¥</b> s√≥ √© calculado quando h√° <b>2 pesagens reais</b> (GMD individual). Se s√≥ existir 1 pesagem, aparece ‚Äú‚Äî (sem hist√≥rico)‚Äù.<br>
    Meteorologia vem automaticamente do Open-Meteo (hist√≥rico) com cache por per√≠odo. Se a API falhar, usa fator conservador.
  </div>
</div>

<script>
/* ===================== CONFIG ===================== */
const SITE = { lat: 38.17355612872988, lon: -7.986520046258665 };

/* Limiares de desempenho (vs m√©dia do grupo, usando GMD INDIVIDUAL real) */
function performanceStatus(gmdInd, gmdMediaGrupo){
  if(!Number.isFinite(gmdInd) || !Number.isFinite(gmdMediaGrupo) || gmdMediaGrupo<=0) return ["‚Äî","muted", 9];
  const r = gmdInd / gmdMediaGrupo;
  if(r >= 0.95) return ["üü¢ Normal","ok", 3];
  if(r >= 0.80) return ["üü° A vigiar","warn", 2];
  return ["üî¥ Atrasado","bad", 1];
}

/* Confian√ßa baseada no tempo desde √∫ltima pesagem */
function confidenceByDays(days){
  if(!Number.isFinite(days)) return ["‚Äî","muted"];
  if(days < 14) return ["Alta","ok"];
  if(days < 35) return ["M√©dia","warn"];
  return ["Baixa","bad"];
}

/* Ajuste por sexo/maturidade (aplicado na estimativa) */
function factorSexo(sexo){ return (clean(sexo).toUpperCase()==="F") ? 0.92 : 1.00; }
function factorMaturidade(peso, sexo){
  const s = clean(sexo).toUpperCase();
  const limiar = (s==="F") ? 460 : 520;
  if(peso < limiar) return 1.00;
  if(peso < limiar + 60) return 0.90;
  return 0.80;
}

/* ===================== HELPERS ===================== */
function clean(s){ return String(s ?? "").trim(); }

function escapeHtml(str){
  return String(str ?? "").replace(/[&<>"']/g, m => ({
    "&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"
  }[m]));
}

function parseNumber(x){
  x = clean(x);
  if(!x) return NaN;
  x = x.replace(",", ".");
  const n = parseFloat(x);
  return Number.isFinite(n) ? n : NaN;
}

/* Datas: YYYY-MM-DD, DD-MM-YYYY, DD/MM/YYYY */
function parseDatePT(s){
  s = clean(s);
  if(!s) return null;

  let m = s.match(/^(\d{4})-(\d{2})-(\d{2})$/);
  if(m){
    const y=+m[1], mo=+m[2], d=+m[3];
    const dt = new Date(Date.UTC(y, mo-1, d));
    return Number.isFinite(dt.getTime()) ? dt : null;
  }

  m = s.match(/^(\d{2})[-\/](\d{2})[-\/](\d{4})$/);
  if(m){
    const d=+m[1], mo=+m[2], y=+m[3];
    const dt = new Date(Date.UTC(y, mo-1, d));
    return Number.isFinite(dt.getTime()) ? dt : null;
  }

  return null;
}

function fmtDate(d){
  if(!d) return "‚Äî";
  const dd = String(d.getUTCDate()).padStart(2,"0");
  const mm = String(d.getUTCMonth()+1).padStart(2,"0");
  const yy = d.getUTCFullYear();
  return `${dd}-${mm}-${yy}`;
}

function daysBetweenUTC(a,b){
  if(!a || !b) return NaN;
  const ms = b.getTime() - a.getTime();
  return Math.floor(ms / (1000*60*60*24));
}

function detectDelimiter(text){
  const first = (text.split(/\r?\n/)[0] || "");
  const semi = (first.match(/;/g)||[]).length;
  const comma = (first.match(/,/g)||[]).length;
  return semi >= comma ? ";" : ",";
}

function isoDateUTC(d){
  const y = d.getUTCFullYear();
  const m = String(d.getUTCMonth()+1).padStart(2,"0");
  const da = String(d.getUTCDate()).padStart(2,"0");
  return `${y}-${m}-${da}`;
}

/* ===================== METEO (Open-Meteo Archive) ===================== */
/*
  Endpoint hist√≥rico:
  https://archive-api.open-meteo.com/v1/archive
  daily=temperature_2m_mean
*/
const meteoCache = new Map(); // key start|end -> {tmean, factor}

function factorFromTempMean(t){
  // simples e est√°vel (podes afinar depois):
  // conforto: <=20 ‚Üí 1.00
  // ligeiro stress: 20-25 ‚Üí 0.95
  // stress moderado: 25-30 ‚Üí 0.85
  // stress alto: >30 ‚Üí 0.70
  if(!Number.isFinite(t)) return 0.95;
  if(t <= 20) return 1.00;
  if(t <= 25) return 0.95;
  if(t <= 30) return 0.85;
  return 0.70;
}

async function getTempMeanForPeriod(startUTC, endUTC){
  const start = isoDateUTC(startUTC);
  const end = isoDateUTC(endUTC);
  const key = `${start}|${end}`;

  if(meteoCache.has(key)) return meteoCache.get(key);

  const url =
    `https://archive-api.open-meteo.com/v1/archive` +
    `?latitude=${SITE.lat}&longitude=${SITE.lon}` +
    `&start_date=${start}&end_date=${end}` +
    `&daily=temperature_2m_mean` +
    `&timezone=auto`;

  try{
    const r = await fetch(url);
    if(!r.ok) throw new Error(`HTTP ${r.status}`);
    const j = await r.json();
    const temps = j?.daily?.temperature_2m_mean || [];
    if(!temps.length){
      const pack = { tmean: NaN, factor: 0.95 };
      meteoCache.set(key, pack);
      return pack;
    }
    const tmean = temps.reduce((a,b)=>a+b,0)/temps.length;
    const pack = { tmean, factor: factorFromTempMean(tmean) };
    meteoCache.set(key, pack);
    return pack;
  }catch(err){
    // fallback conservador
    const pack = { tmean: NaN, factor: 0.95 };
    meteoCache.set(key, pack);
    return pack;
  }
}

/* ===================== UI + PROCESS ===================== */
const statusEl = document.getElementById("status");
const tbody = document.getElementById("tbody");

document.getElementById("fileInput").addEventListener("change", e=>{
  const file = e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = ev => processCSV(ev.target.result);
  reader.readAsText(file);
});

function appendRow(row){
  const tr = document.createElement("tr");
  tr.innerHTML = `
    <td>${escapeHtml(row.animal)}</td>
    <td>${escapeHtml(row.grupo)}</td>
    <td>${escapeHtml(row.sexo)}</td>
    <td>${escapeHtml(row.pesoAtual)}</td>
    <td>${escapeHtml(row.dataAtual)}</td>
    <td>${escapeHtml(row.temp)}</td>
    <td>${escapeHtml(row.fatorClima)}</td>
    <td><b>${escapeHtml(row.estimado)}</b></td>
    <td class="${row.confClass}">${escapeHtml(row.conf)}</td>
    <td class="${row.estadoClass}">${escapeHtml(row.estado)}</td>
  `;
  tbody.appendChild(tr);
}

async function processCSV(csvText){
  tbody.innerHTML = "";

  const delim = detectDelimiter(csvText);
  const lines = csvText.split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
  if(lines.length < 2){
    alert("CSV vazio ou inv√°lido.");
    return;
  }

  // hoje em UTC (para ser consistente)
  const now = new Date();
  const todayUTC = new Date(Date.UTC(now.getFullYear(), now.getMonth(), now.getDate()));

  const header = lines[0].split(delim).map(clean);
  const idx = (name) => header.indexOf(name);

  const i_animal = idx("animal_id") >= 0 ? idx("animal_id") : 0;
  const i_sexo   = idx("sexo") >= 0 ? idx("sexo") : 2;
  const i_grupo  = idx("grupo") >= 0 ? idx("grupo") : 3;
  const i_dant   = idx("data_peso_anterior") >= 0 ? idx("data_peso_anterior") : 4;
  const i_pant   = idx("peso_anterior") >= 0 ? idx("peso_anterior") : 5;
  const i_datual = idx("data_peso_atual") >= 0 ? idx("data_peso_atual") : 6;
  const i_patual = idx("peso_atual") >= 0 ? idx("peso_atual") : 7;

  // 1) Ler rows + construir amostras de GMD INDIVIDUAL por grupo (somente quem tem 2 pesagens v√°lidas)
  const rows = [];
  const gmdIndSamples = {}; // grupo -> [gmdInd]

  for(let li=1; li<lines.length; li++){
    const cols = lines[li].split(delim);

    const animal = clean(cols[i_animal]) || "‚Äî";
    const sexo   = clean(cols[i_sexo]).toUpperCase() || "‚Äî";
    const grupo  = clean(cols[i_grupo]) || "‚Äî";

    const dAnt   = parseDatePT(cols[i_dant]);
    const pAnt   = parseNumber(cols[i_pant]);
    const dAtual = parseDatePT(cols[i_datual]);
    const pAtual = parseNumber(cols[i_patual]);

    let gmdInd = NaN;
    if(dAnt && dAtual && Number.isFinite(pAnt) && Number.isFinite(pAtual)){
      const d = daysBetweenUTC(dAnt, dAtual);
      if(Number.isFinite(d) && d > 0){
        gmdInd = (pAtual - pAnt) / d;
        if(Number.isFinite(gmdInd)){
          (gmdIndSamples[grupo] ||= []).push(gmdInd);
        }
      }
    }

    rows.push({animal, sexo, grupo, dAnt, pAnt, dAtual, pAtual, gmdInd});
  }

  // 2) M√©dia GMD INDIVIDUAL por grupo (para ‚ÄúEstado‚Äù)
  const gmdMediaGrupo = {};
  for(const r of rows){
    const g = r.grupo || "‚Äî";
    if(gmdMediaGrupo[g] == null){
      const arr = gmdIndSamples[g] || [];
      gmdMediaGrupo[g] = arr.length ? (arr.reduce((a,b)=>a+b,0)/arr.length) : NaN;
    }
  }

  // 3) GMD base para estimativa (se n√£o h√° 2 pesagens -> usa m√©dia do grupo; se nem isso -> default)
  const DEFAULT_GMD = 1.4;
  const gmdEstimativaGrupo = {}; // grupo -> number
  for(const r of rows){
    const g = r.grupo || "‚Äî";
    if(gmdEstimativaGrupo[g] == null){
      const arr = gmdIndSamples[g] || [];
      gmdEstimativaGrupo[g] = arr.length ? (arr.reduce((a,b)=>a+b,0)/arr.length) : DEFAULT_GMD;
    }
  }

  // 4) Meteo cache warm-up (um pedido por per√≠odo start|end)
  statusEl.innerHTML = `Separador: <b>${delim}</b> ¬∑ Linhas: <b>${rows.length}</b> ¬∑ A pedir meteorologia‚Ä¶`;

  const periodKeys = new Set();
  for(const r of rows){
    if(r.dAtual){
      periodKeys.add(`${isoDateUTC(r.dAtual)}|${isoDateUTC(todayUTC)}`);
    }
  }

  await Promise.all([...periodKeys].map(async key=>{
    const [s,e] = key.split("|");
    const sD = new Date(Date.UTC(+s.slice(0,4), +s.slice(5,7)-1, +s.slice(8,10)));
    const eD = new Date(Date.UTC(+e.slice(0,4), +e.slice(5,7)-1, +e.slice(8,10)));
    await getTempMeanForPeriod(sD, eD);
  }));

  // 5) Render (ordenar por estado: üî¥ primeiro)
  const rendered = [];
  let ok=0, bad=0;

  for(const r of rows){
    const hasAtual = r.dAtual && Number.isFinite(r.pAtual);
    if(!hasAtual){
      bad++;
      rendered.push({
        sortKey: 99,
        animal:r.animal, grupo:r.grupo, sexo:r.sexo,
        pesoAtual:"‚Äî", dataAtual:"‚Äî", temp:"‚Äî", fatorClima:"‚Äî",
        estimado:"‚Äî", conf:"‚Äî", confClass:"muted",
        estado:"‚Äî", estadoClass:"muted"
      });
      continue;
    }

    const daysSince = daysBetweenUTC(r.dAtual, todayUTC);
    const [conf, confClass] = confidenceByDays(daysSince);

    // clima do per√≠odo
    const meteo = await getTempMeanForPeriod(r.dAtual, todayUTC);
    const fc = meteo.factor;

    // GMD base para estimativa:
    // - se existe gmdInd real -> usa esse
    // - sen√£o -> usa m√©dia do grupo
    const gmdBase = Number.isFinite(r.gmdInd) ? r.gmdInd : (gmdEstimativaGrupo[r.grupo] ?? DEFAULT_GMD);

    // estimativa final com fatores
    const gmdFinal = gmdBase * factorSexo(r.sexo) * factorMaturidade(r.pAtual, r.sexo) * fc;
    const est = r.pAtual + (gmdFinal * daysSince);

    // Estado: s√≥ se existir GMD individual real (2 pesagens)
    let estado="‚Äî (sem hist√≥rico)", estadoClass="muted", sortKey=8;
    if(Number.isFinite(r.gmdInd) && Number.isFinite(gmdMediaGrupo[r.grupo])){
      const [eLbl, eCls, eSort] = performanceStatus(r.gmdInd, gmdMediaGrupo[r.grupo]);
      estado = eLbl;
      estadoClass = eCls;
      sortKey = eSort;
    }

    ok++;
    rendered.push({
      sortKey,
      animal:r.animal,
      grupo:r.grupo,
      sexo:r.sexo,
      pesoAtual:`${r.pAtual.toFixed(1)} kg`,
      dataAtual:fmtDate(r.dAtual),
      temp: Number.isFinite(meteo.tmean) ? `${meteo.tmean.toFixed(1)} ¬∞C` : "‚Äî",
      fatorClima: `<span class="pill">${fc.toFixed(2)}</span>`,
      estimado: Number.isFinite(est) ? `${est.toFixed(1)} kg` : "‚Äî",
      conf, confClass,
      estado, estadoClass
    });
  }

  rendered.sort((a,b)=>a.sortKey-b.sortKey || a.grupo.localeCompare(b.grupo) || a.animal.localeCompare(b.animal));
  tbody.innerHTML = "";
  for(const row of rendered){
    // permitir HTML no pill do fatorClima
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>${escapeHtml(row.animal)}</td>
      <td>${escapeHtml(row.grupo)}</td>
      <td>${escapeHtml(row.sexo)}</td>
      <td>${escapeHtml(row.pesoAtual)}</td>
      <td>${escapeHtml(row.dataAtual)}</td>
      <td>${escapeHtml(row.temp)}</td>
      <td>${row.fatorClima}</td>
      <td><b>${escapeHtml(row.estimado)}</b></td>
      <td class="${row.confClass}">${escapeHtml(row.conf)}</td>
      <td class="${row.estadoClass}">${escapeHtml(row.estado)}</td>
    `;
    tbody.appendChild(tr);
  }

  statusEl.innerHTML =
    `Separador: <b>${delim}</b> ¬∑ Linhas: <b>${rows.length}</b> ¬∑ OK: <b>${ok}</b> ¬∑ Falhas: <b>${bad}</b> ¬∑ ` +
    `Clima: <b>Open-Meteo (hist√≥rico)</b> ¬∑ Local: <b>${SITE.lat.toFixed(4)}, ${SITE.lon.toFixed(4)}</b>`;
}
</script>

</body>
</html>
